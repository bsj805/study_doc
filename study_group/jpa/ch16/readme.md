# 16장 트랜잭션과 락, 2차 캐시

# 16.1 트랜잭션과 락

트랜잭션의 기초와 JPA가 제공하는 낙관적 락과 비관적 락에 대해 알아보자

## 16.1.1 트랜잭션과 격리 수준

- 원자성: 모두 성공 or 모두 실패
- 일관성: 무결성 제약 조건 항상 만족. 트랜잭션은 일관성 있는 DB상태를 유지해야. 도메인 값 유지, 엔티티별 키를 갖고있기, unique하면 unique해야 등등
- 격리성: 다른 트랜잭션이 서로에게 영향을 미치면 안된다. 동시에 같은 데이터에 대한 수정진행 등
- 지속성: 트랜잭션 성공적으로 끝내면 그 결과가 유지되어야 한다. 나중에 복구 가능하게.

 Isolation때문에 트랜잭션은 4단계
 
- READ UNCOMMITTED <- DIRTY READ , NON-REPEATBLE READ, PHANTOM READ 모든 문제 발생 
- READ COMMITTED <- 뒤 두개 . 커밋한 데이터만 읽는다.
- REPEATABLE READ <- PHANTOM READ 하나만
- SERIALIZABLE <- 동시성이 제일 낮아. 격리수준 제일 높아.

* DIRTY READ
트랜잭션 1이 데이터 수정중이고 커밋하지 않았는데 트랜잭션2가 수정된 데이터 접근 가능
* NON-REPEATABLE READ
트랜잭션 1이 처음 데이터 읽었는데, 다른 트랜잭션때문에 데이터가 바뀌고, 트랜잭션 1이 다시 데이터 읽으니 그 데이터가 바뀌어 있다.
* PHANTOM READ
트랜잭션 1이 다시 읽었을때 못 읽었던 value가 추가된 상태로 읽어진다. 
  
## 16.1.2 낙관적 락과 비관적 락 기초
JPA는 READ COMMITTED 정도의 트랜잭션 격리 수준을 가정한다. 다만, 더 높은 격리 수준이 필요하면, 낙관적 락과 비관적 락 중 하나 사용

낙관적 락 : 충돌 발생안한다고 가정하고 진행.
 - JPA의 버전 관리 기능 사용 - 어플리케이션이 제공하는 락이라, 트랜잭션 커밋때까지 트랜잭션 충돌을 몰라.
비관적 락:
 - 트랜잭션 충돌이 발생한다고 가정하고, 락을 걸고 본다. `Select for update` 구문을 사용.

두번 갱신 분실 문제라고, A B가 같은 공지사항을 수정해서 동시에 수정완료를 눌렀으면 뒤에 완료한 값만 남을 것.
- 마지막 수정만 반영
- 최초 수정만 반영
- 충돌 갱신 내용 병합 
이 세개중 선택해야한다.
  
## 16.1.3 @Version

@Version 어노테이션을 사용해 버전 관리 기능을 추가해야.
엔티티 수정때마다 버전이 하나씩 증가한다. 조회시점 버전과 수정시점 버전 다르면 에러.
트랜잭션 1이 조회한 엔티티를 수정하다가 트랜잭션 2에서 같은 엔티티를 수정하고 커밋해서 버전이 증가한다면 에러.

```java
@Version
private Integer version;
```
이걸 엔티티에 붙인다. 이럼 같은 `member1`을 조회했더라도 엔티티 버전값이 바뀌어버리니 최초 수정만 인정하게 된다.

JPA의 버전정보 비교 방법은 DB에 버전 정보까지 담아놓고, 이번 SQL문에서의 VERSION정보가 DB의 버전정보랑 일치할때에만
커밋을 인정한다. 뒤에 들어온 커밋은 무시하게된다. (UPDATE WHERE VERSION=?문으로 조절)


## 16.1.4 JPA 락 사용
JPA가 제공하는 락을 어떻게 사용하는가?

* em.lock(), em.find(), em.refresh()
* query.setLockMode() (native sql 사용할때처럼)
* @NamedQuery (JPQL막 쓸 때)

조회할때 락을 걸 수도 있고, em.find() 후에 em.lock()을 불러서 락을 걸 수도 있다.위에서 말했던 낙관적락, 비관적 락을 쓸 수 있다.

## 16.1.5 JPA 낙관적 락

@Version을 사용한다. 락옵션없이도 낙관적 락이 적용되지만, 더 세밀히 락 옵션을 제어할 수 있다.

* 다른 옵션 안걸었을 때:
엔티티를 수정할 때 다른 트랜잭션에 의해 변경 안되도록 할 때. second lost updates problem 예방 (공지사항 수정)
  
* OPTIMISTIC
@Version만 쓰면 엔티티 `수정` 떄에만 버전 체크하지만 엔티티 조회 때도 버전 체크. 한번 조회한 엔티티가 트랜잭션끝까지 다른 트랜잭션에 의해 변경 x
  
* OPTIMISTIC_FORCE_INCREMENT

음 연관된 객체가 있다면 이걸 관리할 수 있어.
이를테면, 첨부파일 여러개에 하나의 글 엔티티가 있다면, 글을 수정하면서 첨부파일을 추가해도 글의 버전은 바뀌지 않는다.
(List<AttachFile>의 address는 그대로니까) 
강제로 업데이트 할 수 있는 옵션이다.
커밋 시점에 버전을 강제로 증가시킨다. 그냥 트랜잭션에서 커밋을 거치면 증가시키는 방식.

## 16.1.6 JPA 비관적 락
보통 DB transaction lock 메커니즘에 의존한다.
SQL 쿼리 중 `select for update`를 주로 사용해서 시작하고, 버전정보 사용x
Pessimistic_write 모드를 사용한다.

특징
- 엔티티가 아닌 스칼라 타입 조회때도 사용가능
- 데이터 수정 즉시 트랜잭션 충돌 감지 가능

PESSIMISTIC_WRITE
- DB에 쓰기 락을 걸 때에 사용한다. 락이걸린 로우는 다른 트랜잭션이 수정불가

PESSIMISTIC_READ
- 반복 읽기만 가능한 락 필요하면. shared lock 같은느낌 

PESSIMISTIC_FORCE_INCREMENT
- 버전 정보를 증가시켜. 

## 16.1.7 비관적 락과 타임아웃
-비관적 락을 획득할 때 트랜잭션이 락 획득할 때까지 대기한다. -타임아웃을 줄 수 있다

# 16.2 2차 캐시

일반적으로 1차 캐시에서 다 끝난다. 하지만 JPA 구현체들은 어플리케이션 범위 캐시 지원 == 공유 캐시, 2차 캐시
2차캐시에도 없을때에 DB조회.

1차 캐시 특징
- 같은 엔티티 있으면 == 비교 동일
- 영속성 컨텍스트 범위 캐시 == ( 스프링에서는 트랜잭션 범위, OSIV면 요청 단위)

2차 캐시
- JPA는 shared Cache라고 부르지만, 어플리케이션 종료될 때까지 유지되는 캐시이다.

2차캐시동작 방식

1. 영속성 컨텍스트는 엔티티가 필요하면 2차 캐시를 조회
2. 2차 캐시에 엔티티가 없으면 DB조회
3. DB조회후 2차 캐시 보관
4. 2차 캐시가 엔티티 `복사`해서 1차캐시에 반환
5. 같은 엔티티 요청오면 `복사본` 만들어서 반환

즉 == 비교가 실패한다. 

엔티티에 @Cacheable 어노테이션을 붙여야 2차캐시 사용가능하다.
또, persistence.xml (em)에 shared-cache-mode사용 옵션 제공해야.

캐시를 무시하고 직접 DB를 조회하거나, 캐시를 갱신시킬수도 있다.

### JPA 캐시 관리 API

캐시에 있는지
캐시에서 제거
캐시 데이터 초기화
캐시 구현체 조회 등이 있다.

## 16.2.3 하이버네이트와 ECACHE적용
하이버네이트가 지원하는 캐시는 3가지
1. 엔티티 캐시 - 엔티티 단위로 캐시(엔티티 조회, `컬렉션이 아닌` 연관된 엔티티 로딩 시에 사용)
2. 컬렉션 캐시 - 엔티티와 연관된 컬렉션을 캐시한다. 컬렉션이 엔티티를 담고 있으면 식별자 값만 캐시한다. 
3. 쿼리 캐시: 쿼리와 파라미터 정보를 키로 캐시. 결과 엔티티가 있다면 식별자 값만 캐시

JPA 표준은 엔티티 캐시만 하는것.
ECACHE는 2차캐시.

* 엔티티 캐시와 컬렉션 캐시

캐시에 넣을때에도 연관 객체를 캐시에 포함시킬지 말지등을 정할 수 있다.

* 쿼리 캐시
쿼리 캐시는 쿼리와 파라미터 정보를 키로 활용해서 엔티티 식별키를 캐싱해둘 수 있다.
  
캐시를 적용하려는 쿼리마다 setHint 옵션을 주어서 캐시에 둘 수 있다.

쿼리 캐시 영역은
StandardQueryCache : 쿼리 캐시를 저장하는 영역으로, 쿼리, 쿼리 결과 집합, 쿼리 실행시점 타임스탬프 보관 

UpdateTimestampCache : 대상 테이블의 가장 최근 변경 시간을 저장해둔다. 

쿼리 캐시는 캐시한 데이터 집합을 최신으로 유지하기 위해서, 테이블이 가장 최근에 변경된 시간을 비교해야 한다.
테이블에 변경이 조금이라도 있으면 쿼리 결과를 다시 캐시한다. 수정이 빈번하지 않은 테이블에서 사용하는 것이 좋다.

쿼리 캐시나 컬렉션 캐시는 사실 엔티티 정보를 모두 캐싱하는 것은 아니고, 결과집합의 식별자 값만 캐시하기때문에,
그래서 엔티티 캐시에서 조회를 해야한다. 즉 결과 대상에 대해서 엔티티 캐시를 적용해두어야 한다.

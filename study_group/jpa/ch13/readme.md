# 13장, 웹 어플리케이션과 영속성 관리

스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 영속성 컨텍스트를 컨테이너가 관리해서 어플 개발이 쉽다. 하지만 내부 동작방식을 알아야 문제발생시 해결.


## 13.1 트랜잭션 범위의 영속성 컨텍스트

개발이 간편해지긴 해도, 컨테이너가 제공하는 전략을 따라야 한다.

## 13.1.1 스프링 컨테이너 전략
스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다.
트랜잭션 시작과 종료 == 영속성 컨텍스트 시작과 종료.
같은 트랜잭션에서는 같은 영속성 컨텍스트에 접근한다.

`@Transactional` 이걸 붙여서 트랜잭션이 시작되는데, 호출한 메서드를 실행하기 직전에 트랜잭션 AOP가 먼저 작동.
대상 메서드 종료되면서 영속성 컨텍스트가 플러시 된 다음에야 트랜잭션이 커밋된다.
롤백때에는 플러시가 안된다.

다양한 위치에서 엔티티 매니저를 주입받아 사용해도 하나의 트랜잭션 안 이라면 같은 영속성 컨텍스트를 사용한다.
멀티쓰레드라면? 스프링은 스레드마다 다른 트랜잭션.

# 13.2 준영속 상태와 지연 로딩

서비스 바깥의 컨트롤러나 뷰에서는 준영속 상태니까 lazy-loading으로 불러왔으면 그 요소를 사용할때 오류가 난다.
이 경우, 뷰에 필요한 엔티티를 미리 로딩해둘 수 있다.
세가지 방법이 있다

- 글로벌 페치 전략 수정
    - N+1 문제가 있는데, select o from Order o 라고 해봐. 그리고 Member는 order하나를 가지고 있어. 그러면 Order의 o 하나마다 Member을 조회해야한다.
    Member를 먼저 조회했다면 상관없겠지만, order 번호 하나 가지고 Member를 찾아서 써야하니 최악의 경우에는 order 개수만큼 Member에 SQL 을 날린다.
- JPQL 페치 조인
  ~~ join fetch o.member . 처음부터 join 해서 값을 가져와라 하는 것. 하지만 이러면 뷰 계층이 점점 repository 계층을 침범하게 된다. \
- 강제로 초기화
   - 영속성 컨텍스트안에서 `order.getMember().getName()` 이런식으로 강제 초기화. 쓰지도 않을거면서 한번 실행시키기. c언어였으면 optimize되서 생략됐을텐데..
    - hibernate.initialize(order.getMember()) 도 가능하다.
    
## 13.2.4 FACADE 계층
뷰에서 이런식으로 강제 초기화하지 말고, 뷰를 위한 프록시 초기화를 할 수 있는 계층을 두는 것.
FACADE에서 트랜잭션을 시작하고, `order.getMember().getName()` 과 같은것을 호출한다. 이 안에서 서비스의 메서드를 호출하면 된다.

## 13.2.5 준영속 상태와 지연 로딩의 문제점

하지만 이렇게 강제 초기화 쓰는건 번거롭고 놓치기 쉽다. 영속성 컨텍스트를 뷰 계층까지 살아있게 열어두자.

# 13.3 OSIV

Open Session in View. 뷰 에서도 지연로딩을 사용할 수 있게 하자.
과거에는 요청 당 트랜잭션. 하지만 뷰에서 엔티티를 직접 변경할 수도 있다. member.setName("최**"); 이런식으로 썼다면 그대로 플러시가 되버려.
- 엔티티를 읽기전용 인터페이스로 제공
- 엔티티 래핑
  - 읽기전용 클래스 만들어서 거기다 값 만들어서 view쪽에 반환.
- DTO만 반환
 - 프로젝션을 쓰면 거기는 변경 반영안돼.


## 13.3.2 스프링 OSIV
서블릿 필터에서나, 스프링 인터셉터에서 OSIV를 적용할 수 있게 다양한 클래스 제공. 
프레젠테이션 계층에서 데이터 변경가능하다는 것이 문제였는데, 이건 서비스 계층에서만 트랜잭션 사용한다.
다만, 영속성 컨텍스트는 살려두어서, 플러시가 난 다음에도 영속상태가 되도록 한다.
서블릿 필터나, 스프링 인터셉터로 요청이 들어오면 영속성 컨텍스트를 종료한다.em.close()를 한다. flush말고. 강제 플러시 해도 데이터 수정불가능 (transaction바깥이라고)

트랜잭션 없이 읽기.
- 엔티티를 단순 조회할때에는 트랜잭션이 필요없다.
스프링 OSIV가 이런느낌
  
하지만 엔티티 뷰쪽에서 수정하고 바로 트랜잭션 들어가는 서비스 호출하면 문제가 생긴다. 엔티티를 수정한 뒤에는 트랜잭션 호출 말아야.

# 13.4 너무 엄격한 계층
- 컨트롤러에서 리포지토리를 직접 접근
그냥 조회니까, 트랜잭션 없이 그냥 호출하자.
  목

# introduction to performance


## 6.1 case study

n개의 물체에 대한 중력장 영향 시뮬레이션
- 시간을 작은 단계로 나누어서 단계마다 각 물체의 운동을 계산 -> N*N 

Appel은 400배 더 빠르게 진행했어. 


### 요인

- 알고리즘과 데이터 구조 
  - 효율적인 알고리즘을 찾아내자
  - 각 물체에 작용하는 힘이 큰 묶음이 만들어내는 힘으로 근사 (트리 형태로 바꿔서 n^2 -> nlogn 으로 변경)
  - 12배 빨라짐

### 알고리즘 튜닝

- 두 물체가 서로 가까워지는 경우를 처리하려고 항상 작은 시간간격을 사용한다. 
- 아주 드문 일이라 이런 경우에 대해서는 특별한 함수로 처리한다. -> 시간간격을 더 크게 해도 괜찮아졌다.


## 데이터 구조 재구성 

- double precision -> single-precision
- 실행시간 98% 걸리는 함수만 assembly어로 재작성

## 하드웨어

- floating point accelerator가 탑재된 비싼 머신으로 옮겨서 실행함 

# 6.2 디자인의 수준 

## 문제정의
- 컴파일 하는 횟수가 줄어서 개발 기간이 단축된다. 

## 시스템 구조 
- 큰 시스템을 여러 모듈로 나누면 퍼포먼스에 좋을 수 있음.
  - 전체 시스템 스케치 하고, 간단히 계산해볼 줄 알아야 한다. 
  - 기존 시스템 개선하기 보다는 새 시스템을 효율적으로 만드는게 더 쉽다. 


## 알고리즘과 데이터 구조

## 코드 튜닝

## 시스템 소프트웨어
- 시스템 기반이되는 OS를 바꾸거나, 컴파일러 옵션을 활성화한다거나

## 하드웨어
- 하드웨어 빨라지면 퍼포먼스가 좋아지지. 


# 6.3 원리 


아래 컴포넌트 요소가 필요함.
- 안전한
- 디자인 하기 쉬운
- 문서화 하기 쉬운
- 테스트 하기 쉬운
- 유지보수 하기 쉬운


약간의 속도개선이 필요하면 가장 효과 큰 곳만 고쳐라. 

많은 속도개선이 필요하면 여러 수준에서 작업해라. 


# 6.4 연습문제 

## 1. Appel이 실험에 사용한 컴퓨터보다 1000배 빠른 컴퓨터를 사용한다면, 동일한 시간(하루) 내에 몇 개의 물체에 대한 시뮬레이션을 마칠 수 있을까?

O(n^2) 알고리즘 vs O(n logn) 알고리즘에 대해서 각각 답해라.


<details>

1개의 일을 끝내는데 x^2 의 시간이 필요하고, xlogx 만큼의 시간이 필요하다. 

1000배 빠른 컴퓨터를 사용한다면 x=(x/1000) 이 적용될 것이다. 

x^2의 시간에 대해서 10^6 배만큼의 일을 마칠 수 있게되는 것 아닌가? 

(x/1000)(log(x)-log(1000)) == (x/1000) (log(x) -3 ) 

못풀자나?  

같은 조건에서 n^2 개의 operation이 도는 시간, nlogn 개의 operation이 도는 시간은 어떤 함수로 나타날 것이다. 

n=10 , 100, 10
n=100, 10000, 200
n=1000, 1^6, 3000

컴퓨터 속도가 1000배가 빨라진다면, 

n=10이고, 같은 100의 자원이 주어졌을때 n^2은 1번, nlogn 은 10번 할 수 있었던 것이 

n=10이고, 같은 100,000의 자원이 주어진 셈이니까 n^2은 1000번, nlogn은 10000번 할 수 있게된다. 

n=100일때는 같은 100,000의 자원이 주어져서 n^2 은 10번, nlogn은 5000번 할 수 있게된다. 


## 2. 디자인의 여러 수준에서 할 수 있는 속도 개선에 대해 논하라 

- 500자리 정수의 인수분해 
  - 뭐 작게는 2로 안 나누어질 때까지 나누다가, 3으로 안 나누어질 때까지 나누는게 기본적인 방법이겠지. 에라토스테네스의 체 사용해서 소수를 계속 찾아나가야 해. 
  - 더 효율적으로 하려면, 5제곱수, 4제곱수, 3제곱수, 2제곱수 ... 로 먼저 나눠보거나 하면 빠르지 않을까?
- 큰 텍스트 파일에서 특정 문자열 검색
  - divide and conquer해서? 

## 3. double precision -> single precision 하면 2배 빨라짐. 적절한 테스트는? 
- 뭐 곱하기 연산 엄청 때리는거? 

## 4. 이 칼럼에서는 실행 시 효율성을 집중적으로 다루었다. 

퍼포먼스의 다른 척도는

- fault tolerance
- reliability
- security
- price
- performance per price
- accuracy
- robustness 

이를 각 디자인 수준에서 어떻게 풀 수 있는지 논하라 .

(문제정의, 시스템 구조, 알고리즘과 데이터 구조, 코드 튜닝, 시스템 소프트웨어, 하드웨어)


<details>

- fault tolerance
  - 하드웨어: 일반적으로는 하드웨어를 늘리는 것. L4 switch를 두어서 다른 서버로 데이터를 보낸다. 
  - 시스템 구조: 또는 journaling을 통해서 항상 시스템이 살아날 수 있도록 데이터 구조가 journaling 기반으로 작동하게 하는 것
- reliability
  - 항상 같은 input에 대해서 같은 답을 주는지를 어떻게 풀 수 있는가? 
  - 시스템 구조: 테스트하기 좋게 만들어야 한다. 
- security
  - 시스템 소프트웨어: OS를 항상 최신으로 유지한다..? 
- price
  - 시스템 소프트웨어: 무료인 linux를 사용하세 
  - 하드웨어: GPU가 항상 fully utilize되지 않는다면 GPU pool로 전환하자.
- performance per price
  - 알고리즘과 데이터 구조: 더 효율적인 알고리즘을 가져와서 최적화 해야 한다.
- accuracy
  - 정확도.. 결과를 정확하게 낼 수 있느냐 
  - 시스템 구조: 테스트를 잘 짠다
- robustness
  - 시스템 구조: 오류 대응을 잘 할 수 있게 구조화 한다. 


정답:

초기 디자인에서부터 신뢰성을 부여해야한다. 나중에 덧붙일 수 없음.

데이터 구조 손상시 정보 복원 가능하게 설계해라

재검토와 시연을 통해 코드를 면밀히 살피고 광범위하게 테스트해라. 

믿을만한 운영체제와 에러 복구 메모리를 사용하는 중복된 하드웨어 시스템상에서 소ㅠㅡ트웨어를 실행하라. 

복구 계획을 준비하고, 모든 실패를 기록해라. 

</details>

</details>

## 5. 각 디자인 수준에서 최첨단 기법을 이용하는데 드는 비용에 대해 논의해라. 개발 기간, 유지보수 용이성, 현금 등 모든 종류의 비용을 포함 

(문제정의, 시스템 구조, 알고리즘과 데이터 구조, 코드 튜닝, 시스템 소프트웨어, 하드웨어)

- 최첨단 기법은 시스템 구조에 가장 많이 비용을 필요로 할 것 같다 : 학습비용 등


## 6. 효율성은 정확성 다음이다. 프로그램이 잘못된 답을 낸다면 빠른속도도 필요없다. True or False? 

나는 True라고 생각했다. 근데 답변을 보니, 역시 버그는 있는데 돌아가는 시스템이 우선인 경우도 실제 서비스에선 빈번한것 같다.

critical한 failure이 몇개나 있느냐가 중요한 것 같다. 


## 7. 교통사고로 인한 상해와 같은 일상 생활에서의 문제를 어떻게 수준별로 다룰 수 있는 지 논의하라.

(문제정의, 시스템 구조, 알고리즘과 데이터 구조, 코드 튜닝, 시스템 소프트웨어, 하드웨어)

문제 정의: 내가 낸 교통 사고로 상해를 입었을 때 보험비를 지급 안해주려는 보험사에게 보험금을 청구하려고 한다. 

시스템 구조: 보험금 청구 시스템은 내가 이의신청을 제기하고, 소비자 분쟁조정원에서 조정을 해주는 방식이다. 

알고리즘과 데이터 구조: ??... 내가 보상을 받아야 하는 논리를 준비해야 한다. 

코드 튜닝: 내 논리를 한문철 변호사에게 가서 더 깎아야 한다. 

시스템 소프트웨어: 이 세상은 잘못됐다. 헌법소원신청 

하드웨어: ....



컴포넌트: 배포 단위 
- java에서는 jar 같이 하나의 패키지 

# 시간 흐름 별 함수의 메모리 배치

- 고정 메모리 위치에 소스코드의 바이너리 로드
- 어떤 메모리 위치에 있는 바이너리 메모리를 특정 메모리 위치로 옮기는 지능적인 로더를 개발
  - 함수 라이브러리를 로드할 위치, 어플리케이션을 로드할 위치를 로더에게 프로그래머가 지시.
    - 함수 라이브러리 위치가 동적이 되기 때문에 어떤 위치로 옮겨졌는지 hashmap 같은걸 제작하게 됨
      - 이게 라이브러리 함수를 외부참조(external reference) + 이 함수이름과 메모리 위치를 묶는 external definition.
      - 이걸 하는게 linking loader (프로그램 로드와 동시에 링크 수행)

# 링커와 로드가 분리되었다. 링커는 어떤 역할을 한 것일까!


<details>

- 로더는 바이너리파일을 메모리에 재배치하는 역할을 계속 수행
- 링커는 바이너리파일의 외부 라이브러리 참조에 대해 모든 external definition을 만들고, external reference를 만든다.
- c언어에서의 .o 파일 == 실행 파일 == 바이너리파일
  - 왜 다른 라이브러리 참조할때 o파일을 같이 linker에 넣어주는지 == 그 바이너리 파일중에 사용하는 바이너리를 메모리에 로드하기 위함
    - .a파일을 보통 linker에 넣어주긴 하는데, .a는 이런 .o파일의 아카이브 (zip)
- 무어의 법칙 덕분에 속도가 개선되었고, jar파일 여러개도 순식간에 서로에서 사용하는 함수 링크하고, 링크 끝난 프로그램 실행 가능해짐.
- 마크 mod를 추가하려면, jar파일 하나만 추가해도 되는 이유는, 동시에 바이너리 로드할 때 메모리에 추가될 것이기 때문. 

</details>






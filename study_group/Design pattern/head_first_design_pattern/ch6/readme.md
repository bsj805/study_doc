1. strategy 패턴도 행동 등을 분리해서 같은 코드로 여러번 실행할 수 있게 한다. strategy 패턴과 커맨드 패턴의 차이점은?


<details>
<summary> 정답: </summary>
- 커맨드 객체가 존재해서 invoker는 커맨드 객체의 execute만 알고있으면 된다. (단일 호출지점)  <br/>
- 요청하는 객체와 요청을 수행하는 객체를 분리하는 게 커맨드 패턴 <br/>
- 객체의 알고리즘을 캡슐화해서 알고리즘을 수정해서 쓸 수 있도록 하는게 strategy 패턴  <br/>
</details>


2. 커맨드 패턴을 활용해서 로그 및 트랜잭션 시스템을 구현할 수 있다고 한다. 어떤 컨셉일까?

<details>
<summary> 정답: </summary>
- 모든 커맨드 객체와 연관된 리시버들은 커맨드 객체의 execute()를 거치기 때문에 로깅이 쉽다. - 모든 행동 sequence를 로깅해두면 failover가 가능 <br/>
- 트랜잭션도 모든 요청이 커맨드 객체를 통하게 함으로써, 어떤 sql 쿼리의 시작점과 끝점이 관리될 수 있게 한다. <br/>
</details>

3. 커맨드객체 와 옵저버 패턴의 유사점과 차이점

<details>
<summary> 정답: </summary>
- 둘 다 행동을 위임받는 객체가 있고, 리시버 객체가 어떤 일을 하는지 몰라도 특정 메서드를 구현했음만 알고 있으면 된다  <br/>
- 둘다 객체들을 등록하긴 하지만 옵저버는 1:n 브로드캐스트 방식으로 작동하고, 커맨드객체는 등록된 객체 하나만 작동시키게 된다. (그게 매크로 객체일수도 있지만) <br/>
</details>


4. 책에서는 작업 큐를 소개해서, 매 스레드가 작업큐에 있는 커맨드 객체를 가져다가 execute()를 호출하는 방식을 설명한다. 웹서버에서 이런 큐를 어떻게 활용할 수 있을까? (책에 나온 질문) 

<details>
<summary> 정답: </summary>
- 원초적으로는 event queue를 두어서 요청을 큐에 적재하고, 이벤트 스레드가 큐에 있는 요청을 처리(execute) <br/>
</details>

5. NULL 객체의 역할은?

<details>
<summary> 정답: </summary>
- 생성자에 넣어서 null check를 안해도 되도록 하는 객체. null check 코드 대신 존재해서 코드가 훨씬 보기 편하다. <br/>
</details>

1. 옵저버 패턴을 사용하기 좋은 use case

<details>
<summary> 정답: </summary>
- 하나의 동작이 여러 행동을 유발 시킬 때
    - 센서 모니터링 등
- 등록되었다가 등록을 취소하는 등 유연한 동작이 가능해야 할 때 (동적 구독, 구독 취소)
    - grafana 대시보드 같은
- 내부 동작 방식이 너무 다양할 때에
    - 한 행동이 일어났을 때 A는 a1, a2를 불러줘야 하고, B는 b1 , b2, b3 를 불러줘야 한다면 이를 모두 인터페이스화 하기는 어렵다.
</details>

2. 옵저버에서의 loose coupling이란?

<details>
<summary> 정답: </summary>
* 객체들이 상호작용 가능하지만 서로를 잘 모르는 관계이다.
    * 인터페이스를 구현했다는 사실만 사용한다. 옵저버의 행동은 뭔지 모른다.
* 각 토픽, 구독하는 객체는 독립적인 객체로도 사용가능하다. 
* 옵저버 인터페이스만 변경한다면 주제나 옵저버 인터페이스가 달라지더라도 재사용이 쉽다.
</details>

3. (java유저인데,) 인터페이스로 구현하고 싶지 않고 추상 슈퍼 클래스를 통해 메서드를 강제하면 안될까요?

<details>
<summary> 정답: </summary>
책에서는 인터페이스가 중의적인 ( 상위에 존재하는 형식 ) 의미로 사용되었기 때문에, 추상 슈퍼 클래스를 사용핻 ㅗ된다. 
아무튼 실제 객체의 형식을 몰라도 된다는 점이 중요하다.

</details>

4. 좋은 객체지향 디자인의 요소는 무엇일까?

<details>
<summary> 정답: </summary>
* 캡슐화를 잘 하기
* 추상화를 잘 하기
* 상속을 잘 하기
* 다형성을 잘 알기 
</details>

5. 적용할만한 좋은 디자인 패턴을 찾을 수 없을 때에는 어떻게 해야 하는가?

<details>
<summary> 정답: </summary>

* 사실 패턴의 밑바닥에는 객체지향 패턴이 존재한다. 그런 원칙만 알고 있다면, 관리가 용이한 객체지향 시스템을 만드는 비결이 된다.
* 나중에 어떻게 바뀔 것인지 생각을 잘 해서 구조를 짜야 한다. 그 역할을 패턴이 해주려던 것이고.

</details>
커넥션 관리
# 4.1 TCP 커넥션

패킷 교환 네트워크 프로토콜 집합인 TCP/IP
- 커넥션이 맺어지면 메시지 손실, 손상, 순서변경 없이 전달

http://www.naver.com:80/abc.html

1. 브라우저가 URL에서 호스트로 IP 주소
2. 브라우저가 URL에서 포트번호
3. 브라우저가 TCP 커넥션 생성
4. 브라우저가 서버로 GET
5. 브라우저가 서버의 응답 읽는다
6. 브라우저가 커넥션 종료


## 4.1.2 TCP 스트림(데이터)는, 세그먼트로 나뉘어 IP 패킷으로 전달

IP 패킷 이라는 작은 조각으로 데이터 전송

TCP 와 어플리케이션(HTTP) 계층사이 TLS or SSL (암호화) 들어간게 HTTPS

일반적으로

- HTTP
- TCP
- IP
- NETWORK interface

TCP 세션 연결되었다 가정, 메시지 데이터 내용 순서대로 전달
- 세그먼트라는 단위로 데이터 스트림을 잘게 나눈다
- IP 패킷으로 감싸서 인터넷으로 데이터 전달.
  - 구조가 아래와 같다
    - IP 패킷 헤더 (발신지, 목적지 IP 가짐)
      - TCP 세그먼트 헤더 (TCP 포트 번호, 데이터 순서, 무결성 검사)
      - TCP 데이터조각 (size>=0)



## 4.1.3 TCP 커넥션 유지
컴퓨터는 항상 여러 개의 TCP 커넥션 유지. (포트 번호별로 하나의 TCP 연결 유지가능)

내 컴퓨터 IP 2개면 각각 다른 IP로 같은 대상서버 IP, 같은 대상서버 포트로 TCP 두개 연결 가능.


## 4.1.4 TCP 소켓 프로그래밍

소켓 API로 
- TCP endpoint 데이터 구조 생성
- 상대 TCP endpoint에 데이터 구조 연결해서 데이터 스트림에 읽고 쓰기 가능

순서
1. 서버에서 소켓생성
2. bind
3. 소켓 커넥션 허가(listen)
4. accept(커넥션 기다리기)

허용하는거랑 blocking상태로 상대의 tcp 패킷 받는거랑 다른거. (상태 vs 동작)


# 4.2 TCP 성능

HTTP 지연은 TCP 네트워크 지연으로 발생

지연 원인
1. DNS 연결 IP 알아내기
2. 서버에서 tcp 커넥션 허용응답 오기 기다리기
3. 서버로 실제메시지 보내기
4. 서버에서 응답받기


## 4.2.2 성능 주요요소

핸드셰이크 

확인 응답 지연
- 순번, 데이터 무결성 체크 
- 세그먼트 수신자가 세그먼트 받을 때 확인응답보냄
- 안오면 다시 전송
- 보통 확인응답이랑 메시지랑 묶어서 보내려고 확인응답 지연 알고리즘 (TCP 스택에)

TCP 느린 시작
- 속도제한 높여나가는거 (TCP 커넥션 만들어진 뒤부터)
- 2배씩 보낸다 (congestion window)

작은 크기 패킷 여러개
- 하나당 헤더 40byte
- 네이글 알고리즘: 패킷 전송전에 TCP 데이터 합쳐서 보내기. ( 세그먼트 최대 크기 MTU 되지 않으면 전송 안하기. 다만 다른 모든 패킷의 확인응답 있다면 보내기.)

TIME_WAIT 누적, 포트 고갈
- TCP endpoint에서 TCP 끊으면 커넥션 IP와 포트번호를 control block에 기록. 
- 같은 주소, 포트 사용하는 새로운 커넥션 일정시간동안 생성안되게 함.
  - 이전 커넥션과 연관된 패킷이 새로운 커넥션에 들어오는걸 막는다.
- 시간이 2MSL(segment lifetime)
- 클라이언트는 서버의 80번 포트로 TCP 연결 맺을때 매번 다른 발신지 포트 쓸텐데, 클라이언트 발신지포트는 60000개정도로 제한되어있다.

# 4.3 HTTP 커넥션 관리

## 4.3.1 Connection 헤더
HTTP는 프락시 서버, 캐시 서버 등 중개서버가 있을 수도 있다. 특정 인접 HTTP 어플리케이션의 커넥션에만 적용될 옵션 지정가능. (HTTP connection 헤더 필드)
- 다음 커넥션엔 전달 안된다. (삭제되야함) - hop by hop 헤더명을 적어준다.

## 4.3.2 순차적인 트랜잭션 처리에 의한 지연

3개 이미지 웹페이지 - 4개 HTTP 커넥션. 

# 4.4 병렬 커넥션

여러개 TCP 커넥션 맺어서 동시에 다운받기.
- 단, 네트워크 대역폭 좁으면 sequential하게 받아질것. 
- 메모리 많이 소모. (수백개 커넥션 열면? 서버 성능 떨궈) 
- 4개정도의 병렬 커넥션만 허용

# 4.5 지속 커넥션

보통 같은 서버에 계속 요청할 것. HTTP/1.1 은 persistent connection 지원
- TCP 느린 시작도 방지
- handshake 방지

병렬 + 지속으로 사용

Connection:Keep-Alive 헤더  HTTP/1.0 , 아무튼 헤더에 계속 넣어서 보내주면 서버가 대응해주거나, 서버 대응 못하면(응답헤더에 없이 보내면) 아예 Keep-Alive 안되는구나 받아들여

Timeout 있어서 얼마간 유지할지 보내주고, max http transaction 명시가능


## 4.5.6 dumb proxy

프록시가 Connection 헤더를 이해 못해서 요청 그대로 다음 프록시로 전달하면, hop-by-hop 헤더라 프록시가 서버랑 keep-alive하는건줄안다. 

프록시는 커넥션을 끝내는줄 알고 그 뒤의 클라이언트 요청 안받는다.

넷스케이프는 Proxy-Connection 확장 헤더를 프록시에게 전달해서, 웹서버는 무시하는 헤더로 인식할 수 있다. 

프록시가 connection 헤더로 바꿔서 인식한다. 다만, 하나의 proxy 있을 때만 작동. 브라우저는 심지어 프록시 몇개인지 모른다.


## 4.5.8 HTTP/1.1

HTTP는 기본으로 지속 커넥션. 그래서 HTTP app은 커넥션 끝나면 Connection:close 헤더에 보내야. 사실 뭐 누구나 언제든 끊을 순 있다.

## 4.5.9 지속 커넥션 규칙

- 자신의 길이 정보를 정확히 가지고 있어야 커넥션 지속됨.
- 프락시는 클라이언트와 서버 각각에 대한 별도의 지속 커넥션 가진다.
- HTTP app은 중간에 끊어지는 커넥션 복구 가능해야. 
- 클라이언트는 전체 응답 못받았으면 다시 요청보내야.

## 4.6 파이프라인 커넥션

여러 요청 파이프라이닝 

HTTP 메시지는 순번 x , HTTP 응답이 요청 순서랑 똑같이 와야한다.  (다음 응답 안와도 요청 여러개 보내놓고 순차적으로 응답을 받는다)

POST처럼 서버 데이터 변화생길 수 있는 경우 에러가 발생했을 때 어떤 요청이 처리된것인지 모를 수 있다.  (nonIdempotent 요청 - 항상 같은 결과 나오는게 아닌 요청)
- 비멱등성 요청은 이전 요청 응답 기다려야 한다.

## 4.7 커넥션 끊기 미스테리
명확한 기준 없음

- content-length 와 truncation
  - 클라이언트가 커넥션 끊어졌다고 HTTP 응답 받은 뒤, 실제 전달된 엔티티 길이랑 content-length일치 안하면 다시 서버에 요청

## 4.7.4 우아한 커넥션 끊기

TCP 입출 채널 한개만 끊을 수 있다.(shutdown()) close는 전체 끊기

클라이언트가 입력 채널 끊긴 socket에 보내면 `connection reset by peer` 
 - 내 버퍼에 있는 메시지를 지우는 게 대부분. 
 - 중복해서 날린 tcp 메시지였는데 내 버퍼의 메시지를 지울 수도 있다. 그럼 응답데이터가 어떤 요청에 대한 응답인지 몰라서 응답데이터도 못써먹는 효과




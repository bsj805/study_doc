# 15장 entity and encoding

HTTP는 콘텐츠를 전달하기 위해 잘 라벨링한 엔터티를 활용한다.

 
# 15.1 메시지는 컨테이너, 엔터티는 화물

HTTP 메시지 안에 HTTP 엔터티가 들어있다.

엔터티 헤더는 엔터티 본문 이전 Content에 대한 정보

```html
Content-Type: text/plain
Content-length: 18

Hi' I am a message (엔터티 본문)
```

- Last-Modified
- Expires
- Allow 어떤 요청메서드 허용되는지
- ETag 
- Cache-Control 어떻게 문서가 캐시될 수 있는지

이렇게까지는 엔터티 헤더


## 15.1.1 엔터티 본문

가공되지 않은 데이터만 담고있다. 
 - 이미지던, 바이너리던, 텍스트던 다 

# 15.2 Content-Length: 엔터티의 길이
인코딩 되었더라도 엔티티 본문의 크기를 바이트 단위로 표현
- 잘림 검출
  - 커넥션 닫힌건지, 서버로부터의 전송이 실패한건지 파악 가능 (캐싱 프락시 서버는 잘린 메시지로 응대할 가능성)
- Persistent Connection
  - 하나의 메시지 끝이 어디인지 알 수 있다. 
  - 다만 chunk encoding을 쓰면 Content-Length 헤더없이 청크가 들어온다.

## 15.2.5 엔터티 본문 길이 판별 규칙
1. HEAD메서드 같은 경우 Content-length 있던 없던 헤더이후 응답끊어야
2. Transfer-Encoding 헤더 있는 메시지는 0바이트청크 패턴으로 끝나야함.(메시지 끝)
3. multipart/byteranges : 멀티파트 메시지 각 부분이 스스로의 크기 정의함
4. 커넥션 닫으면 끝내

# 15.3 엔터티 요약
메시지 일부가 변형되는 일이 있을 수 있다.
- 체크섬 생성 - 수신자가 검사 (Content-MD5: 엔티티 본문에 알고리즘 적용)
  - 실제 메시지에 대해서 계산해야함(압축으로 보냈으면 gzip에 대한 MD5)
  - MD5는 잘 사용안됨. Want-Digest로 우선순위 놓고 클라이언트와 선택 

# 15.4 미디어 타입과 Charset
Content-Type에 MIME타입 작성
- multipart/byteranges
  - 엔터티 본문이 여러 부분으로 나뉘는데, 각 부분이 전체 문서의 특정 범위를 바이트 단위로 담고 있다. 
  - 각 부분이 자신에 대해 서술하는 헤더를 포함하는형태.
- multipart/form-data : 폼에 채워 전송하면 멀티파트 데이터

# 15.5 콘텐츠 인코딩
- 느린속도 클라이언트면 압축할 수 있다.
  - 발송하는 쪽에서 콘텐츠에 적용

## 15.5.1 콘텐츠 인코딩 과정

1. 서버의 원본 메시지 생성
2. 콘텐츠 인코딩 서버에서 압축, Content-Encoding 헤더를 인코딩된 메시지에 추가해서, 수신 측 어플이 디코딩하게
3. 수신측 프로그램이 디코딩해서 원본얻기

## 15.6 전송 인코딩과 청크 인코딩
- 텍스트는 JPEG로 압축하지 않아. 압축률이 달라.
  - 컨텐츠 인코딩된 메시지는 엔터티 본문만 인코딩
  - 전송 인코딩 된 메시지는 메시지 전체를 인코딩


# 15.6 안전한 전송
문제 원인은 알수 없는 크기, 보안 등이다. 
- 서버측이 컨텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기 판단 불가
  - 그래서 특별한 종결 꼬리말같은거 사용하는거

Transfer-Encoding: 수신자에게 어떤 인코딩으로 전송 인코딩되었는지 알려준다.

청크 인코딩: 메시지를 일정 크기의 청크 여럿으로 쪼개고, 각 청크 순차적으로 보낸다. -메시지의 속성. 멀티파트 인코딩은 본문의 속성. 얘랑 다름.
- 지속 커넥션시에는, 동적으로 생성할 때 Content-Length모른채로 시작할 수 있음. 크기 0 청크 보내.
- `0<CR><LF>` 이런걸로 마침. 
- 청크 메시지에 트레일러 추가
  - Content-MD5 처럼 어떤 컨텐츠 있는지 모를때 못보냈던 헤더도 보낼 수 있다.

## 15.6.4 콘텐츠와 전송 인코딩의 조합
- 콘텐츠 인코딩으로 HTML 파일 압축, 후 청크 데이터를 전송 인코딩으로 보낼 수 있다. 

# 15.7 시간에 따라 바뀌는 인스턴스
문서가 다른시점엔 달라질 수 있다.
- 인스턴스 조작 ( 특정 요청, 응답 다루는 방법 정의 )
  - 범위 요청
  - 델타 인코딩

이 두가지 다 클라이언트의 리소스 사본 검사 및 새 인스턴스 요청 능력

# 15.8 검사기와 신선도

신선도: 서버가 Expires 나 Cache-Control 헤더로 내려주는, 컨텐츠의 validity 정보
- expires가 그 서버간 시간 동기화되어 있는것을 요구하는 
- Cache-Control은 max age. 초 단위 수명

- If-Modified-Since, If-Unmodified-Since : Last-modified 평가
  - 약한 검사기
- If Match , If-None-Match는 Etag 값을 평가
  - 강한 검사기

서버가 ETag 헤더에 매 변경마다 바뀌는 값을 넣어야 한다. 
- weak Entity tag임을 알리면 상관없고, W"v4.0" 처럼.

# 15.9 범위 요청
문서 일부만 요청할 수 있다.
- 파일의 3/4 만 다운받은경우. 
  - Range: bytes=4000- : 첫 4000byte만 갖고있는 경우
  - 병렬로 하나의 파일 다운받는데 사용할 수도 있다.

# 15.10 델타 인코딩
로컬사본에서 변경된 부분만 서버가 보내준다면?
- 델타 인코딩이 변경된 부분만 보내는 HTTP 프로토콜 확장이다. 
- 클라이언트가 페이지 어떤 버전 갖고있는지 보내면, 서버는 차이를 체크해서 새 식별자 명시해서 보내주면 된다.
  - 클라이언트는 ETAG를 보낸다. + A-IM 헤더를 보내 델타를 받아들인다고 보낸다. 
  - 델타로 클라이언트 페이지 재구성하는 알고리즘 목록 보내서 협상(IM- Instance Manipulation 헤더로 서버가 응답) 
   


